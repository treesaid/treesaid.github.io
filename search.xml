<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何将vue初始项目发布到github上]]></title>
    <url>%2F2017%2F10%2F09%2F%E5%A6%82%E4%BD%95%E5%B0%86vue%E5%88%9D%E5%A7%8B%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E5%88%B0github%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[一、vue项目的创建 首先第一肯定是要有Node.js及npm这个不多说了 安装脚手架 此时可以直接浏览-但是现在肯定有很多小白想将他发布到gitHub上并可以浏览，使用vue全家桶制作自己的博客。 现在就有我来说说如何讲vue项目发布到github上 二、vue项目的打包大家都知道使用npm run build进行打包，这个时候你直接打开dist/下的index.html,会发现文件可以打开，但是所有的js，css，img等路径有问题是指向根目录的，此时需要修改config/index.js里的assetsPublicPath的字段，初始项目是/他是指向项目根目录的也是为什么会出现错误，这时改为./ 12345678910111213141516171819build: &#123; env: require('./prod.env'), index: path.resolve(__dirname, '../dist/index.html'), assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: './', productionSourceMap: true, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, productionGzipExtensions: ['js', 'css'], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125; 在从dist根目录打开index文件就可以访问了。 三、github pages 首页创建一个仓库，此处直接忽略 在这里选择master或者/doc 上传代码到master 上面有一行域名就是你自己的页面可以看到自己发布的项目 四、自定义域名这个时候就可以浏览自己的项目了，但是123username.github.io/xxx/dist 这样的地址着实不是很美观，大家可以去阿里云上，自己买个域名，解析一下，网上都有，可以进行自定义的域名，来制作的自己的博客，代码部署到github上。这篇文章这里就先不做讲解了，有想使用自定义域名，也可以私信我。 原文地址：https://segmentfault.com/a/1190000009527796]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>前端</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0中的transition动画]]></title>
    <url>%2F2017%2F09%2F27%2Fvue2-0%E4%B8%AD%E7%9A%84transition%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[总括： transition 之前只是作为元素的一个属性，到了2.0以后 transition成为了一个组件，也就意味着有更多的功能123&lt;transition name="fade"&gt; 运动的东西(html元素、属性、路由...)&lt;/transition&gt; class定义：123456789101112131415161718.fade-enter-active,.fade-leave-active&#123; transition:1s all ease;&#125;.fade-enter-active&#123; //变成什么样子-&gt;当元素出来（显示） opactiy:1; width:300px; height:300px;&#125; .fade-leave-active&#123; //当元素离开（消失） width:100px; height:100px; opacity:0&#125;.fade-enter, .fade-leave&#123; //初始的状态 width:100px; height:100px; opacity:0&#125; transition 相关函数的接口1234567891011121314methods:&#123; afterLeave(el)&#123; el.style.background:'red' &#125;&#125;@before-enter="beforEnter" 动画enter之前@enter="enter" 动画enter@afterEnter="afterEnter" 动画enter之后@before-leave="beforeLeave" 动画leave之前@leave="leave" 动画leave@afterLeave="afterLeave" 动画leave之后&lt;transition name="fade" @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter" &gt;&lt;/transition&gt; 如何配合animate.css 使用详细的动画效果参考：Animate.css官网12345&lt;link rel="stylesheet" type="text/css" href="animate.css" /&gt;&lt;transition enter-active-class="bounceInLeft" leave-active-class="bounceOutRight"&gt; &lt;p class="animtaed"&gt;&lt;/p&gt;&lt;/transition&gt;//放大效果 zoomInLeft zoomOutRight 注意：必须给transition里面包裹的运动元素添加 animatedclass 才可以 transition 多个元素运动1234&lt;transition-group enter-active-class="bounceInLeft" leave-active-class="bounceOutRight"&gt; &lt;p :key="1"&gt;&lt;/p&gt; &lt;p :key="2"&gt;&lt;/p&gt; &lt;/transition-group&gt; 完整实例code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue2.0中的transition动画&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;style&gt; p&#123; width:300px; height:300px; background: red; &#125; .fade-enter-active, .fade-leave-active&#123; transition: 1s all ease; &#125; .fade-enter-active&#123; opacity:1; width:300px; height:300px; &#125; .fade-leave-active&#123; opacity:0; width:100px; height:100px; &#125; .fade-enter,.fade-leave&#123; opacity:0; width:100px; height:100px; &#125; &lt;/style&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload=function()&#123; new Vue(&#123; el:'#box', data:&#123; show:false &#125; &#125;); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;input type="button" value="点击显示隐藏" @click="show=!show"&gt; &lt;transition name="fade"&gt; &lt;p v-show="show"&gt;&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS居中小谈]]></title>
    <url>%2F2017%2F09%2F27%2FCSS%E5%B1%85%E4%B8%AD%E5%B0%8F%E8%B0%88%2F</url>
    <content type="text"><![CDATA[总括： CSS居中一直是一个比较敏感的话题，为了以后开发的方便，楼主觉得确实需要总结一下了，总的来说，居中问题分为垂直居中和水平居中，实际上水平居中是很简单的，但垂直居中的方式和方法就千奇百怪了。 内联元素居中方案水平居中设置：行内元素 设置 text-align:center；Flex布局 设置父元素display:flex;justify-content:center;(灵活运用) 垂直居中设置：父元素高度确定的单行文本（内联元素） 设置 height = line-height； 父元素高度确定的多行文本（内联元素）a:插入 table （插入方法和水平居中一样），然后设置vertical-align:middle；b:先设置 display:table-cell 再设置 vertical-align:middle； 块级元素居中方案水平居中设置：定宽块状元素 设置 左右 margin 值为 auto； 不定宽块状元素 a:在元素外加入 table 标签（完整的，包括 table、tbody、tr、td），该元素写在 td 内，然后设置 margin 的值为 auto； b:给该元素设置 display:inine 方法； c:父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:50%； 垂直居中设置： 使用position:absolute（fixed）,设置left、top、margin-left、margin-top的属性(定高); 12345678910.box &#123; width: 200px; height: 200px; background: red; position: absolute;/*或fixed*/ top: 50%; left: 50%; margin-top: -100px; margin-left: -100px;&#125; 利用position:fixed（absolute）属性，margin:auto这个必须不要忘记了(不定高不定宽); 1234567891011.box&#123; width: 100px; height: 100px; background: red; position: absolute;/*或fixed*/ top:0; right:0; bottom:0; left:0; margin: auto;&#125; 利用display:table-cell属性使内容垂直居中,这个方法在多行文字居中的时候用的比较多;HTML代码： 123&lt;div class="box"&gt; &lt;span&gt;多行文字，此处居中设置&lt;/span&gt;&lt;/div&gt; CSS代码： 123456789101112.box&#123; display: table-cell; vertical-align: middle; text-align: center; width: 100px; height: 120px; background: purple;&#125;.box span&#123; display: inline-block; vertical-align: middle;&#125; 使用css3的新属性transform:translate(x,y)属性(不定高，不定宽);HTML代码： 123&lt;div class='box'&gt; 垂直居中&lt;/div&gt; CSS代码: 123456789.box&#123; position: absolute; top:50%; left:50%; transform: translate(-50%,-50%); -webkit-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%);&#125; 使用before，after伪元素(定高不定宽);HTML代码： 12345&lt;div class='box'&gt; &lt;div class='content'&gt; 垂直居中 &lt;/div&gt;&lt;/div&gt; CSS代码： 12345678910111213141516171819202122.box&#123; display: block; background: rgba(0,0,0,.5); height: 100px;&#125;.content::before&#123; content: ''; display: block; vertical-align: middle; height: 100%;&#125;.content::after&#123; content: ''; display: block; vertical-align: middle; height: 100%;&#125;.box .content&#123; height: 33px; line-height: 33px; text-align: center;&#125; Flex布局(不定高，不定宽); 12345678910111213141516171819202122.box&#123; display: -webkit-box; display: -webkit-flex; display: -moz-box; display: -moz-flex; display: -ms-flexbox; display: flex; /*水平居中*/ -webkit-box-align: center; -moz-box-align: center; -ms-flex-pack:center; -webkit-justify-content: center; -moz-justify-content: center; justify-content: center; /*垂直居中*/ -webkit-box-pack: center; -moz-box-pack: center; -ms-flex-align:center; -webkit-align-items: center; -moz-align-items: center; align-items: center;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6常见用法总结]]></title>
    <url>%2F2017%2F09%2F26%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[什么是ECMA？ECMA是标准，js是实现类似HTML5是标准，IE10，chrom，FF都是实现 目前版本：低级浏览器：主要支持ES3.1高级浏览器：正在从ES5过渡到ES6 历史： 1996 ES1.0 js稳定 Netscape将js提供给ECMA组织，ES正式出现 1998 ES2.0 ES2.0正式发布 1999 ES3.0 ES3被浏览器被广泛支持 2007 ES4.0 ES4过于激进，被废除了 2008 ES3.1 4.0退化为严重缩水版的3.1，代号Harmony（和谐） 2009 ES5.0 ES5.0正式发布 ，同时公布了Javascript.next也就是后来的6.0 2011 ES5.1 ES5.1成为ISO国际标准 2013 ES6.0 ES6.0 制定草案 2013.12 ES6.0 ES6.0草案发布 2015.6 ES6.0 ES6.0预计发布正式版，同时JavaScript.next指向ES7.0 兼容性：目前为止 ES5 ES6支持情况，凑合nodejs用的就是chrom内核，在node中可以使用ES5 ES6很多特性ES5 和 ES6 已经逐渐沦为后台语言 在浏览器里如何使用? 需要用到编译工具babel traceur —由Google出的编辑器，把ES6语法编译为ES5 bootstrap 引导程序，跟css里面认识bootstrap不一样 在网页上使用 用法一： 1234&lt;script type="text/javascript" src="traceur.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="bootstrap.js"&gt;&lt;/script&gt;&lt;script type="module"&gt; &lt;/script&gt; 用法二：直接在线编译—主要用于测试 1bable:http://babeljs.io/repl/ 用法三：直接在node里面使用 12a). 直接用，需要添加 'use strict'b). node --harmoney_destructuring 1.js 新增常用语法1.定义变量 let 已经被浏览器实现了let —用来去定义变量 代码块：{}包起来的代码，形成了一个作用域，块级作用域比如 if 、for、while 特点:只能在代码块里面使用var 只有函数作用域 1234a). let 具备块级作用域b). 不允许重复声明 let a =12; let a =5; //错误 总结：其实let才接近其他语言的变量 用处：封闭空间：（匿名函数自调用） 123(function()&#123; var a=12;&#125;)() 现在： 123&#123; let a=12;&#125; i值问题: 123456789之前的解决办法： var aBtn=document.getElementsByTagName('input') for(var i=0;i&lt;aBtn.length;i++)&#123; (function(i)&#123; aBtn[i].onclick=function()&#123; alert(i) &#125; &#125;)(i) &#125; 12345678es6 let解决办法： var aBtn=document.getElementsByTagName('input') for(let i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].onclick=function()&#123; alert(i) &#125; &#125; &#125; 总结: 块级作用域，其实就是匿名函数自调用 2. const —用来定义 常量一旦赋值，以后再也修改不了了 注意：const必须给初始值 ，不能重复声明因为以后再也没办法赋值了，所以声明的时候一定得有值 作用：为了防止意外修改变量比如引入库名，组件名 3.字符串连接：之前：12var str="";var str=''; 反单引号： var str=`` 字符串模板12之前: "abc'+变量名+'ef"现在：`abc$&#123;变量名&#125;ef`]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中keep-alive用法]]></title>
    <url>%2F2017%2F09%2F26%2Fvue%E4%B8%ADkeep-alive%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[路由开启keep-alive时的注意点因为原文已经写得很详细了，我这里就不在赘述了。原文地址:http://xiangsongtao.com/article/5853b2c0044bf1353af82fbf]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Less常见用法]]></title>
    <url>%2F2017%2F09%2F26%2FLess%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.在less中引入另一个less文件1@import "ku"; //引入的是（ku.less）文件; 在less中引入一个css文件1@import(less) "a.css"; 2.嵌套规则（less中最有意思的部分)1234567891011121314151617181920212223.ul&#123; width:600px; margin: 30px auto; padding: 0; list-style:none; li&#123; height: 30px; background: pink; line-height: 30px; margin-bottom: 5px; padding: 0 10px; &#125; a&#123; float: left; //&amp;代表上一级选择器 &amp;:hover&#123; color:#000; &#125; &#125; span&#123; float: right; &#125;&#125; 3.混合的用法（也很常用） .border-01{border:2px solid @ccc} 1调用：.test-hunhe&#123;.border-01;width:200px;height:200px&#125; .border-02(@w){border:@w solid #ccc} 1调用：.test-hunhe&#123;.border-02(10px),width:200px;height:200px&#125; .border-03(@w:10px){border:@w solid #ccc} 1调用：.test-hunhe&#123;.border-03(),width:200px;height:200px&#125; 4.变量less中想声明一个变量的话一定要用@开头，例如：@w：20px； width:@w; 5.运算（less中的运算 +-*/）1234@test:200px;.box-01&#123;width:@test-20;&#125;; //less中一个带单位,另一个可以不写单位； 180px.box-01&#123;width:@test-20*5;&#125;; 100px.box-01&#123;width:(@test-20)*5;&#125; //加（）提高优先级 6.@arguments 变量@arguments包含了所有传递进来的参数如果你不想单独处理每一个参数的话就可以像这样写123456.border-arg(@w:5px,@xx:solid,@c:black)&#123; border:@arguments; &#125;.test-arg&#123; .border-arg(10px); &#125; 7.z.less 库中的常见用法123456789101112131415161718192021222324.fl(); //float:left.fr(); //float:right.clearfix(); //clear:both;.bc() //margin:0 auto; .rel(); //position:relative.abs(); //position:absolate.fix(); //position:fixed;.h100(); //height:100%;.l-h(100px); //line-height:100px;.d-b(); //display:block.d-i(); //display:inline.d-ib(); //display:inline-block.font-fm(); //font-family:"Microsoft Yahei","微软雅黑";.font-s(14px); //font-size:14px;(默认12px).font-wb(); //font-weight:bold;.tl(); //text-align:left.tc(); //text-align:center.tr(); //text-align:right;.opa(50) //opacity:0.5; (默认值80).bg("../img/logo.png",@x:0,@y:0) //background:url('../img/logo.png') 0 0 no-repeat.ellipsis() //文字省略号 ( )内部使用百分比，例如.ellipsis(8) 出来的结果就是width:92%;.border-radius(10px) //border-radius:10px(默认值:5px)]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>less</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0正确地引用 jquery 和 jquery-ui的插件]]></title>
    <url>%2F2017%2F09%2F22%2Fvue2-0%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%BC%95%E7%94%A8-jquery-%E5%92%8C-jquery-ui%E7%9A%84%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[出自: http://www.itnose.net/detail/6647297.html使用vue-cli构建的vue项目，webpack的配置文件是分散在很多地方的，而我们需要修改的是build/webpack.base.conf.js，修改两处的代码12345678910111213141516171819202122232425262728293031// 在开头引入webpack，后面的plugins那里需要var webpack = require('webpack')// resolvemodule.exports = &#123; // 其他代码... resolve: &#123; extensions: ['', '.js', '.vue'], fallback: [path.join(__dirname, '../node_modules')], alias: &#123; 'src': path.resolve(__dirname, '../src'), 'assets': path.resolve(__dirname, '../src/assets'), 'components': path.resolve(__dirname, '../src/components'), // webpack 使用 jQuery，如果是自行下载的 // 'jquery': path.resolve(__dirname, '../src/assets/libs/jquery/jquery.min'), // 如果使用NPM安装的jQuery 'jquery': 'jquery' &#125; &#125;, // 增加一个plugins plugins: [ new webpack.ProvidePlugin(&#123; $: "jquery", jQuery: "jquery" &#125;) ], // 其他代码...&#125; 这样就可以正确的使用jQuery了，比如我要引入Bootstrap，我们在vue的入口js文件src/main.js开头加入123// 使用Bootstrapimport './assets/libs/bootstrap/css/bootstrap.min.css'import './assets/libs/bootstrap/js/bootstrap.min' vue-cli webpack全局引入jquery首先在package.json里加入123dependencies:&#123; "jquery" : "^2.2.3"&#125; 然后 nmp install 在webpack.base.conf.js里加入1var webpack = require("webpack") 在module.exports的最后加入1234567plugins: [ new webpack.optimize.CommonsChunkPlugin('common.js'), new webpack.ProvidePlugin(&#123; jQuery: "jquery", $: "jquery" &#125;)] 然后一定要重新 run dev在main.js 引入就ok了1import $ from 'jquery']]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this、call、apply、bind]]></title>
    <url>%2F2017%2F09%2F22%2Fthis%E3%80%81call%E3%80%81apply%E3%80%81bind%2F</url>
    <content type="text"><![CDATA[这又是一个面试经典问题~/(ㄒoㄒ)/~~也是 ES5中众多坑中的一个，在 ES6 中可能会极大避免 this 产生的错误，但是为了一些老代码的维护，最好还是了解一下 this 的指向和 call、apply、bind 三者的区别。 this 的指向在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象，来，跟着我朗读三遍：this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象。记住这句话，this 你已经了解一半了。 下面我们来看一个最简单的例子：例 1： 12345678var name = "windowsName";function a() &#123; var name = "Cherry"; console.log(this.name); // windowsName console.log("inner:" + this); // inner: Window&#125;a();console.log("outer:" + this) // outer: Window 这个相信大家都知道为什么 log 的是 windowsName，因为根据刚刚的那句话“this 永远指向最后调用它的那个对象”，我们看最后调用 a 的地方 a();，前面没有调用的对象那么就是全局对象 window，这就相当于是 window.a()；注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property &#39;name&#39; of undefined。 再看下这个例子：例 2：12345678var name = "windowsName";var a = &#123; name: "Cherry", fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn(); 在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。是不是有一点清晰了呢~ 我们做一个小小的改动：例 3：12345678var name = "windowsName"; var a = &#123; name: "Cherry", fn : function () &#123; console.log(this.name); // Cherry &#125; &#125; window.a.fn(); 这里打印 Cherry 的原因也是因为刚刚那句话“this 永远指向最后调用它的那个对象”，最后调用它的对象仍然是对象 a。 我们再来看一下这个例子：例 4：12345678var name = "windowsName";var a = &#123; // name: "Cherry", fn : function () &#123; console.log(this.name); // undefined &#125;&#125;window.a.fn(); 这里为什么会打印 undefined 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 this.name 的值是 undefined。 这个例子还是说明了：this 永远指向最后调用它的那个对象，因为最后调用 fn 的对象是 a，所以就算 a 中没有 name 这个属性，也不会继续向上一个对象寻找 this.name，而是直接输出 undefined。 再来看一个比较坑的例子：例 5：12345678910var name = "windowsName";var a = &#123; name : null, // name: "Cherry", fn : function () &#123; console.log(this.name); // windowsName &#125;&#125;var f = a.fn;f(); 这里你可能会有疑问，为什么不是 Cherry，这是因为虽然将 a 对象的 fn 方法赋值给变量 f 了，但是没有调用，再接着跟我念这一句话：“this 永远指向最后调用它的那个对象”，由于刚刚的 f 并没有调用，所以 fn() 最后仍然是被 window 调用的。所以 this 指向的也就是 window。 由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，永远是this 永远指向最后调用它的那个对象。 再来看一个例子：例 6：123456789var name = "windowsName";function fn() &#123; var name = 'Cherry'; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn() 读到现在了应该能够理解这是为什么了吧(oﾟ▽ﾟ)o。 怎么改变 this 的指向改变 this 的指向我总结有以下几种方法： 使用 ES6 的箭头函数 在函数内部使用 _this = this 使用 apply、call、bind new 实例化一个对象 例 7：12345678910111213var name = "windowsName";var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function 在不使用箭头函数的情况下，是会报错的，因为最后调用 setTimeout 的对象是 window，但是在 window 中并没有 func1 函数。 我们在改变 this 指向这一节将把这个例子作为 demo 进行改造。 箭头函数众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。箭头函数的 this 始终指向函数定义时的 this，而非执行时。，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。 例 8 ：12345678910111213var name = "windowsName";var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry 在函数内部使用 _this = this如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。例 9：123456789101112131415var name = "windowsName";var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; var _this = this; setTimeout( function() &#123; _this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry 这个例子中，在 func2 中，首先设置 var _this = this;，这里的 this 是调用 func2 的对象 a，为了防止在 func2 中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将 this(指向变量 a) 赋值给一个变量 _this，这样，在 func2 中我们使用 _this 就是指向对象 a 了。 使用 apply、call、bind使用 apply、call、bind 函数也是可以改变 this 的指向的，原理稍后再讲，我们先来看一下是怎么实现的： 使用 apply例 10：123456789101112var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.apply(a),100); &#125;&#125;;a.func2() // Cherry 使用 call例 11：123456789101112var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.call(a),100); &#125;&#125;;a.func2() // Cherry 使用 bind例 12：123456789101112var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.bind(a)(),100); &#125;&#125;;a.func2() // Cherry apply、call、bind 区别刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。 在 MDN 中定义 apply 如下； apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数 语法： fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 apply 和 call 的区别其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。 call 的语法为：12fun.call(thisArg[, arg1[, arg2[, ...]]])` 所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。 例 13：12345678var a =&#123; name : "Cherry", fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.apply(a,[1,2]) // 3 例 14：12345678var a =&#123; name : "Cherry", fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.call(a,1,2) // 3 bind 和 apply、call 区别我们先来将刚刚的例子使用 bind 试一下12345678var a =&#123; name : "Cherry", fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2) 我们会发现并没有输出，这是为什么呢，我们来看一下 MDN 上的文档说明： bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用：12345678var a =&#123; name : "Cherry", fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)() // 3 ==================================== 更新============================== JS 中的函数调用如果不理解为什么 例 6 的 innerFunction 和 例 7 的 this 是指向 window 的，所以我就来补充一下 JS 中的函数调用。例 6：123456789var name = "windowsName";function fn() &#123; var name = 'Cherry'; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn() 例 7：12345678910111213var name = "windowsName";var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function 函数调用的方法一共有 4 种 作为一个函数调用 函数作为方法调用 使用构造函数调用函数 作为函数方法调用函数（call、apply） 作为一个函数调用比如上面的 例 1：例 1：12345678var name = "windowsName";function a() &#123; var name = "Cherry"; console.log(this.name); // windowsName console.log("inner:" + this); // inner: Window&#125;a();console.log("outer:" + this) // outer: Window 这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined。 但这是一个全局的函数，很容易产生命名冲突，所以不建议这样使用。 函数作为方法调用所以说更多的情况是将函数作为对象的方法使用。比如例 2：例 2：12345678var name = "windowsName";var a = &#123; name: "Cherry", fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn(); 这里定义一个对象 a，对象 a 有一个属性（name）和一个方法（fn）。 然后对象 a 通过 . 方法调用了其中的 fn 方法。 然后我们一直记住的那句话“this 永远指向最后调用它的那个对象”，所以在 fn 中的 this 就是指向 a 的。 使用构造函数调用函数 如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象： 123456789// 构造函数:function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125; // This creates a new objectvar a = new myFunction("Li","Cherry");a.lastName; // 返回 "Cherry" 这就有要说另一个面试经典问题：new 的过程了，(ಥ_ಥ)这里就简单的来看一下 new 的过程吧：伪代码表示：1234567var a = new myFunction("Li","Cherry");new myFunction&#123; var obj = &#123;&#125;; obj.__proto__ = myFunction.prototype; var result = myFunction.call(obj,"Li","Cherry"); return typeof result === 'obj'? result : obj;&#125; 创建一个空对象 obj; 将新创建的空对象的隐式原型指向其构造函数的显示原型。 使用 call 改变 this 的指向 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。 所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。 作为函数方法调用函数 在 JavaScript 中, 函数是对象。 JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身 在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。 这个时候我们再来看例 6：例 6：123456789var name = "windowsName";function fn() &#123; var name = 'Cherry'; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn() 这里的 innerFunction() 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下就是 window 调用的） 然后再看一下 例 7：例 7：12345678910111213var name = "windowsName";var a = &#123; name : "Cherry", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100 ); &#125;&#125;;a.func2() // this.func1 is not a function 这个简单一点的理解可以理解为“匿名函数的 this 永远指向 window”，你可以这样想，还是那句话this 永远指向最后调用它的那个对象，那么我们就来找最后调用匿名函数的对象，这就很尴尬了，因为匿名函数名字啊，笑哭，所以我们是没有办法被其他对象调用匿名函数的。所以说 匿名函数的 this 永远指向 window。 如果这个时候你要问，那匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊，比如例 7 中的 setTimeout。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>原声js</tag>
      </tags>
  </entry>
</search>
